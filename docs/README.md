# Документация
Пара общих слов. Разрабатывалось и тестировалось все под Ubuntu 12.04, если под другими окружениями что-то идет не так, обязательно сообщайте.

Я не ставил себе задачу создать незабываемый user experience, так что если использовать что-то не по назначению, компоненты могут падать. Например, если вместо лог-файла открыть картинку с котиком или пытаться использовать в качестве движка утилиту `rm`, все упадет. Трейсбек скорее всего будет вменяемым. 
##Установка
Если слово virtualenv вам ни о чем не говорит, что порядок действий такой:
- [установить wxPython](http://www.wxpython.org/download.php);
- выполнить `python setup.py install`.

Если же вы хотите установить все в virtualenv, то wxPython все равно проще всего  установить глобально, а virtualenv выполнить с параметром `--system-site-packages`. С альтернативными решениями этой проблемы можно ознакомиться [здесь](http://stackoverflow.com/questions/10457647/).
##durak-gui
Простое GUI, в котором можно сразиться с выбранным движком. (Да, запускается командой `durak-gui`). Сторонний движок можно добавить в меню Настройки -> Выбрать движок. В остальном должно быть все понятно, в дурака играли все.
##durak-autoplay
Консольная утилита для проведения матчей между двумя движками.

Пример вызова:
```
$ durak-autoplay durak-dummy durak-dummy
Playing 10 matches, 100 games each
1000 of 1000
Engine1 (durak-dummy) scores:	4.0
Engine2 (durak-dummy) scores:	6.0

Match 1 - Engine1 wins: 46, Engine2 wins: 40, Draws: 14
Match 2 - Engine1 wins: 38, Engine2 wins: 42, Draws: 20
Match 3 - Engine1 wins: 37, Engine2 wins: 40, Draws: 23
Match 4 - Engine1 wins: 46, Engine2 wins: 35, Draws: 19
Match 5 - Engine1 wins: 38, Engine2 wins: 39, Draws: 23
Match 6 - Engine1 wins: 44, Engine2 wins: 42, Draws: 14
Match 7 - Engine1 wins: 44, Engine2 wins: 42, Draws: 14
Match 8 - Engine1 wins: 37, Engine2 wins: 49, Draws: 14
Match 9 - Engine1 wins: 37, Engine2 wins: 38, Draws: 25
Match 10 - Engine1 wins: 35, Engine2 wins: 43, Draws: 22
```
Движок `durak-dummy` сыграл 10 матчей по 100 игр в каждом против себя же самого. 4 раза выиграл, 6 раз програл. Ничья.

Два обязательных позиционных аргумента: путь к движку 1 и путь в движку 2. Оба движка должны быть исполняемыми файлами.

Необязательные аргументы:
  - `--matches-number` - сколько матчей играть, по умолчанию 10;
  - `--match-size` - сколько игр в каждом матче, по умолчанию 100;
  - `--log-file` - путь к файлу, куда писать лог игры. По умолчанию ничего, и лог соответственно не пишется;
  - `--debug` - выводит в stderr лог взаимодействия с движками. По умолчанию выключено.

##durak-logviewer
Запускаем программу (`durak-logviewer`), выбираем файл лога, выбираем игру и смотрим. Сложно сделать что-то не так. :-)
##Как написать свой движок
Движок - это исполняемый файл, который принимает команды в stdin и пишет что-то в stdout. Команд всего 6, вот они:
  1. `init <карта>` - начинает новую игру. <карта> - это козырь, который лежит под колодой и который видно обоим игрокам. Формат карт см. ниже. Пример - `init 6S`. **Ожидаемый ответ движка** - `ok`.
  2. `deal <одна_или_более_карт_через_пробел> ## GAMEDATA` - раздает карты из колоды. Формат карт и что такое GAMEDATA см. ниже. Пример (без GAMEDATA) - `deal 6S 7D`. **Ожидаемый ответ движка** - `ok`.
  3. `move <карты_на_столе_через_пробел> ## GAMEDATA` - "ходите!". Команда означает, что ход движка.  Формат карт на столе и что такое GAMEDATA см. ниже. Пример (без GAMEDATA) - `move 6S 7S`. **Ожидаемый ответ движка** - `<карта>` или пустая строка, что значит "бито". Если на столе карт пока нет, то только `<карта>`.
  4. `respond <карты_на_столе_через_пробел> ## GAMEDATA` - "отбивайтесь!". Команда означает, что движку надо побить карту, котрой против него пошли, или взять.  Формат карт на столе и что такое GAMEDATA см. ниже. Пример (без GAMEDATA) - `respond 6S`. **Ожидаемый ответ движка** - `<карта>` или пустая строка, что значит "беру".
  5. `give_more <карты_на_столе_через_пробел> ## GAMEDATA` - "подкидывайте еще!". После того, как соперник сказал "беру", ему можно подкинуть еще подходящих карт.  Формат карт на столе и что такое GAMEDATA см. ниже. Пример (без GAMEDATA) - `give_more 6S 7S 6H`. **Ожидаемый ответ движка** - `<карты_через_пробел>` или пустая строка, что значит "не хочу ничего подкидывать".
  6. `game_end` - конец игры. В ответ нужно завершать работу.

### Формат карт
Карта передается как строка из двух ascii-символов - достоинство карты и масть. 

Возможные достоинства: `6`, `7`, `8`, `9`, `T` (десятка), `J` (валет), `Q` (дама), `K` (король), `A` (туз).

Возможные масти: `C` (трефы), `D` (бубны), `H` (червы), `S` (пики).

Примеры карт: `QS` - пиковая дама, `7C` - семерка треф, `JD` - бубновый валет.

Почему именно такие буквы для обозначения мастей и крупных карт? Это сокращения от их [английских названий](http://en.wikipedia.org/wiki/Standard_52-card_deck).

Если нужно передать список из нескольких карт, то в качестве разделителя используется пробел.

### Формат карт на столе
В некоторых командах передается, какие карты лежат на столе. Например, `7H QH 7S 8D 8S`. Это означет, что на столе: лежит семь червей, которая побита дамой червей; 7 пик, которая побита 8 бубей; и 8 пик, которая пока ничем не побита.

Коротко - если вести счет с 0, то четных местах лежат карты, которыми ходили, а на нечетных - карты, которыми отбивались.

### Gamedata
В большинстве команд упоминается какая-то GAMEDATA. Это JSON, который содержит дополнительную информацию об игре: какие карты вышли, сколько кард осталось в колоде и т. п. Ваш движок может использовать эту информацию, а может и игнорировать. Реальный пример команды `respond`:
```
respond 6S ## {"discarded": ["6C", "7C"], "deck_count": 22, "on_table": ["6S"], "enemy_count": 5, "trump": "TD"}
```
Описания полей:
  - `discarded` - список вышедших кард в порядке выбывания;
  - `deck_count` - количество кард, оставшихся в колоде;
  - `on_table` - список кард на столе;
  - `enemy_count` - количество карт у соперника;
  - `trump` - открытый козырь.

### Пример взаимодействия с движком
Давайте посмотрим на пример (можно проделать это самому, комментарии (после `//`) вводить не нужно):
```
$ durak-dummy
init TD  // начинаем новую игру, козырь -десятка бубей
ok
deal QS 7C KS QC 6S 9S ## {"discarded": [], "deck_count": 24, "on_table": [], "enemy_count": 6, "trump": "TD"}  // сдаем 6 карт, передаем GAMEDATA
ok
respond 6C ## {"discarded": [], "deck_count": 24, "on_table": ["6C"], "enemy_count": 5, "trump": "TD"}  // предположим соперник нашего движка пошел с шестерки треф
7C  // наш движок побил ее семеркой
respond 6C 7С 6H ## {"discarded": [], "deck_count": 24, "on_table": ["6C", "7C", "6H"], "enemy_count": 4, "trump": "TD"}  // подкинем шестерку червей
 // нашему движку нечем бить, он берет
deal 6C 7C 6H ## {"discarded": [], "deck_count": 22, "on_table": [], "enemy_count": 6, "trump": "TD"}  // он получает обратно карты со стола
```

И так далее.

### Объяснение каких-то решений в протоколе
**Я что, не могу сразу пойти в двух или трех карт? Обязательно ходить ими по одной?** Да, это сознательное решение. Я не вижу каких-то минусов в этом, а протокол получается очень простым: сходил-побил, сходил-побил.

**Зачем эта GAMEDATA? Да еще через разделитель. Почему бы все не передавать через JSON?** Это возможное решение. Но мне кажется, так легче читать, а программе и так, и так удобно.

 **Почему нет правила "первый отбой - 5 карт"? Зачем менять правила?** Без этого правила проще писать движки. А мне очень хочется, чтобы их было просто писать. При этом я слабо представляю, как отсутствие этого правила может стать решающим. (Я тестировал разные наборы движков на большом количестве игр с этим правилом и без. Я не увидел, чтобы оно на что-то влияло.)
 
 [Еще вопросы?](mailto:drtyrsa@yandex.ru)
 
 ### Подводные камни
  - не забывайте flush'ить stdout после того, как пишете туда. Иначе вывод может буферизироваться, а это не то, что нам нужно;
  - когда подидываете карты через `give_more`, помните, что нельзя отдать сопернику своих карт больше, чем у него было в начале хода. Например, у вас 10 карт, у соперника - 6. Максимум, вы можете выложить на стол 6 своих карт. Больше - ошибка.

### Примеры движков
Пример пока один - `durak-dummy`. Исходники на Питоне лежат здесь же - `durak/engine/dummy.py` Он использует `durak/engine/base.py`, который можно использовать как основу для движков на Питоне.